import { OpenAI } from 'langchain/llms/openai';
import { ChatOpenAI } from "langchain/chat_models/openai";
import { ChatPromptTemplate } from "langchain/prompts";
import { LLMChain, ConversationChain} from "langchain/chains";
import { JsonOutputFunctionsParser, StructuredOutputParser } from "langchain/output_parsers";
import { BufferMemory } from "langchain/memory";
import { Ollama } from "langchain/llms/ollama";
import dotenv from 'dotenv'; 
import { AIMessage, ChainValues } from 'langchain/dist/schema';
import { RunnableSequence } from "langchain/schema/runnable";


import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";


dotenv.config();




export class GenAI {



next_system_template = `You are a text-based role-playing game based on Dungeons and Dragons. 
Game Rules:
 This is a purely fictional world, so the user is allowed to take actions, including fighting monsters.
 Players will gain 1 level for every monster killed.  After a monster is killed they can loot the body and get a treasure they may add to 
 their inventory.  Players can only use items in their inventory. To start with each player is level 1 and has a sword in their inventory. 
 A player wins at level 10. 
 
Fighting rules:
 The player and the monster are both assigned a random number between 1 and 5.  Whomevers number is higher wins the attack.  
 The losers health is lowered by the difference between the numbers.
 A player and a monster both have 10 health points.  
 For a monster or player,  when their health
 gets to zero they die.
 
 Items added to a players inventory should be added to the sword in their inventory list.


 On each turn you will take the following actions:
 1. If the player tells you their name,  greet them and explain the rules and then create an exciting scene based on Dungeons and Dragons.
 2. If the player presents you with an action they took based on the scene history,  simulate that action and report to them the resulting scene. 
 3. Give the player at least 3 actions they can take based on the scene.  

 
 The output should be formatted as a JSON object with 3 paramaters for player details, the scene that was created, and the options created.
 `

 zodSchema = z.object({
  player: z.object({
    name: z.string().describe("name of the player"),
    level:z.string().describe("level of the player"),
    health:z.string().describe("health of the player"),
    inventory:z.array(z.string().describe("item in the players inventory")),
  }).describe("metadata about the player"),
  scene: z.object({
    description: z.string().describe("Description of the scene the player is in"),
    monsters:z.array(z.string().describe("if there are any monsters list them here")),
    treasure:z.array(z.string().describe("if there is any treasure list it here")),
  }).describe("metadata about the player"),
  options: z.array(z.string().describe("option generated by the game")
    .describe("an array of options generated by the game"))



});

  model = new ChatOpenAI({
    temperature:1,
    modelName:'gpt-3.5-turbo',
    topP:1
  })
  
  functionCallingModel = this.model.bind({
    functions: [
      {
        name: "output_formatter",
        description: "Should always be used to properly format output",
        parameters: zodToJsonSchema(this.zodSchema),
      },
    ],
    function_call: { name: "output_formatter" },
  });




  parser = new JsonOutputFunctionsParser();

  memory = new BufferMemory();



  constructor() {}
  nextmove(nextmove: NextMove){
    console.log('move')
    const chatPrompt = ChatPromptTemplate.fromMessages([
      ["system", this.next_system_template],
      ["human", `Given the following pipe delemited history I will take action listed:
          Player: {player},
          Action: {action},

      `]
    ]);
    const chain = chatPrompt.pipe(this.functionCallingModel).pipe(this.parser);
    return chain.invoke({
      player: nextmove.player,
      action: nextmove.action
    })
  }

  startGame(start: GameStart) {

    
    console.log('start game')
    const chatPrompt = ChatPromptTemplate.fromMessages([
      ["system", this.next_system_template],
      ["human", "Hello, my name is {name}"]
    ]);
    const chain = chatPrompt.pipe(this.functionCallingModel).pipe(this.parser);

    const result  =  chain.invoke({
      name: start.name
    })

    return result;
    

  }
}

export class GameStart{
  name:string = ""
}
export class NextMove{
  player:object =  {};
  scenes:string[]=[];
  action:string="";
}